---
title: Queries, Mutations & Subscriptions
sidebar_label: Queries, Mutations & Subscriptions
---

SwiftGraphQL lets you query data, perform mutations and even listen for subscriptions. Since queries and mutations don't differ much on the API level, they share the same method `send`. Subscriptions, on the other hand, use `subscribe` method. Each of these functions has a type check that makes sure you can actually query what you are querying and mutating what is mutable.

When it comes to the usage flow, all three operations follow the same principle.

1. You create a query selection that tells the client what it should query and how it should decode the result.
1. Using `send` or `subscribe` you communicate with the server.

## Examples

```swift
let query = Selection.Query {
    let list = try $0.humans(human.list)
    let nullable = try $0.human(id: "100", human.nullable)

    return list
}

send(query, to: "http://localhost:4000") { result in
    if let data = try? result.get() {
        print(data)
    }
}

let subscription = Selection.Subscription {
    let list = try $0.humans(human.list)
    let nullable = try $0.human(id: "100", human.nullable)

    return list
}

// Start the event.
let url = URL(string: "ws://localhost:4000/subscriptions")!
let session = URLSessionWebSocketTask(url: url, headers: [:])
let socket = GraphQLSocket(session, autoConnect: true)


let cancellable = socket.subscribe(to: subscription) { [weak self] result in
    if let data = try? result.get() {
        print(data)
    }
}
```

> ❗️ NOTE: You should handle the closing of sockets. SwiftGraphQL intentionally doesn't handle websocket state and only implements the decoding and sending mechanism.
